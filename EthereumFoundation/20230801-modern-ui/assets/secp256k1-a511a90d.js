import{H as Wt,h as It,i as it,t as Xt,w as Qt,r as M,j as Jt,n as de,k as dt,l as Ft,m as Z,v as wt,o as C,p as j,q as zt,s as he,u as Ot,x as be,y as Tt,z as ge,A as te}from"./index-ce540db3.js";function we(e,n,t,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(n,t,r);const s=BigInt(32),o=BigInt(4294967295),f=Number(t>>s&o),c=Number(t&o),i=r?4:0,a=r?0:4;e.setUint32(n+i,f,r),e.setUint32(n+a,c,r)}class me extends Wt{constructor(n,t,r,s){super(),this.blockLen=n,this.outputLen=t,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=It(this.buffer)}update(n){it.exists(this);const{view:t,buffer:r,blockLen:s}=this;n=Xt(n);const o=n.length;for(let f=0;f<o;){const c=Math.min(s-this.pos,o-f);if(c===s){const i=It(n);for(;s<=o-f;f+=s)this.process(i,f);continue}r.set(n.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){it.exists(this),it.output(n,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:o}=this;let{pos:f}=this;t[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>s-f&&(this.process(r,0),f=0);for(let l=f;l<s;l++)t[l]=0;we(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=It(n),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=i/4,b=this.get();if(a>b.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)c.setUint32(4*l,b[l],o)}digest(){const{buffer:n,outputLen:t}=this;this.digestInto(n);const r=n.slice(0,t);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:o,destroyed:f,pos:c}=this;return n.length=s,n.pos=c,n.finished=o,n.destroyed=f,s%t&&n.buffer.set(r),n}}const ye=(e,n,t)=>e&n^~e&t,xe=(e,n,t)=>e&n^e&t^n&t,Ee=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),et=new Uint32Array(64);class ee extends me{constructor(){super(64,32,8,!1),this.A=tt[0]|0,this.B=tt[1]|0,this.C=tt[2]|0,this.D=tt[3]|0,this.E=tt[4]|0,this.F=tt[5]|0,this.G=tt[6]|0,this.H=tt[7]|0}get(){const{A:n,B:t,C:r,D:s,E:o,F:f,G:c,H:i}=this;return[n,t,r,s,o,f,c,i]}set(n,t,r,s,o,f,c,i){this.A=n|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=f|0,this.G=c|0,this.H=i|0}process(n,t){for(let l=0;l<16;l++,t+=4)et[l]=n.getUint32(t,!1);for(let l=16;l<64;l++){const B=et[l-15],E=et[l-2],w=M(B,7)^M(B,18)^B>>>3,u=M(E,17)^M(E,19)^E>>>10;et[l]=u+et[l-7]+w+et[l-16]|0}let{A:r,B:s,C:o,D:f,E:c,F:i,G:a,H:b}=this;for(let l=0;l<64;l++){const B=M(c,6)^M(c,11)^M(c,25),E=b+B+ye(c,i,a)+Ee[l]+et[l]|0,u=(M(r,2)^M(r,13)^M(r,22))+xe(r,s,o)|0;b=a,a=i,i=c,c=f+E|0,f=o,o=s,s=r,r=E+u|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,f=f+this.D|0,c=c+this.E|0,i=i+this.F|0,a=a+this.G|0,b=b+this.H|0,this.set(r,s,o,f,c,i,a,b)}roundClean(){et.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class pe extends ee{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const mt=Qt(()=>new ee);Qt(()=>new pe);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const U=BigInt(0),H=BigInt(1),ot=BigInt(2),Be=BigInt(3),Nt=BigInt(4),Dt=BigInt(5),Kt=BigInt(8);BigInt(9);BigInt(16);function T(e,n){const t=e%n;return t>=U?t:n+t}function ve(e,n,t){if(t<=U||n<U)throw new Error("Expected power/modulo > 0");if(t===H)return U;let r=H;for(;n>U;)n&H&&(r=r*e%t),e=e*e%t,n>>=H;return r}function K(e,n,t){let r=e;for(;n-- >U;)r*=r,r%=t;return r}function Lt(e,n){if(e===U||n<=U)throw new Error(`invert: expected positive integers, got n=${e} mod=${n}`);let t=T(e,n),r=n,s=U,o=H;for(;t!==U;){const c=r/t,i=r%t,a=s-o*c;r=t,t=i,s=o,o=a}if(r!==H)throw new Error("invert: does not exist");return T(s,n)}function Se(e){const n=(e-H)/ot;let t,r,s;for(t=e-H,r=0;t%ot===U;t/=ot,r++);for(s=ot;s<e&&ve(s,n,e)!==e-H;s++);if(r===1){const f=(e+H)/Nt;return function(i,a){const b=i.pow(a,f);if(!i.eql(i.sqr(b),a))throw new Error("Cannot find square root");return b}}const o=(t+H)/ot;return function(c,i){if(c.pow(i,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,b=c.pow(c.mul(c.ONE,s),t),l=c.pow(i,o),B=c.pow(i,t);for(;!c.eql(B,c.ONE);){if(c.eql(B,c.ZERO))return c.ZERO;let E=1;for(let u=c.sqr(B);E<a&&!c.eql(u,c.ONE);E++)u=c.sqr(u);const w=c.pow(b,H<<BigInt(a-E-1));b=c.sqr(w),l=c.mul(l,w),B=c.mul(B,b),a=E}return l}}function Ae(e){if(e%Nt===Be){const n=(e+H)/Nt;return function(r,s){const o=r.pow(s,n);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(e%Kt===Dt){const n=(e-Dt)/Kt;return function(r,s){const o=r.mul(s,ot),f=r.pow(o,n),c=r.mul(s,f),i=r.mul(r.mul(c,ot),f),a=r.mul(c,r.sub(i,r.ONE));if(!r.eql(r.sqr(a),s))throw new Error("Cannot find square root");return a}}return Se(e)}const Ie=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ne(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Ie.reduce((r,s)=>(r[s]="function",r),n);return wt(e,t)}function qe(e,n,t){if(t<U)throw new Error("Expected power > 0");if(t===U)return e.ONE;if(t===H)return n;let r=e.ONE,s=n;for(;t>U;)t&H&&(r=e.mul(r,s)),s=e.sqr(s),t>>=H;return r}function _e(e,n){const t=new Array(n.length),r=n.reduce((o,f,c)=>e.is0(f)?o:(t[c]=o,e.mul(o,f)),e.ONE),s=e.inv(r);return n.reduceRight((o,f,c)=>e.is0(f)?o:(t[c]=e.mul(o,t[c]),e.mul(o,f)),s),t}function Ut(e,n){const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Oe(e,n,t=!1,r={}){if(e<=U)throw new Error(`Expected Fp ORDER > 0, got ${e}`);const{nBitLength:s,nByteLength:o}=Ut(e,n);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=Ae(e),c=Object.freeze({ORDER:e,BITS:s,BYTES:o,MASK:Jt(s),ZERO:U,ONE:H,create:i=>T(i,e),isValid:i=>{if(typeof i!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof i}`);return U<=i&&i<e},is0:i=>i===U,isOdd:i=>(i&H)===H,neg:i=>T(-i,e),eql:(i,a)=>i===a,sqr:i=>T(i*i,e),add:(i,a)=>T(i+a,e),sub:(i,a)=>T(i-a,e),mul:(i,a)=>T(i*a,e),pow:(i,a)=>qe(c,i,a),div:(i,a)=>T(i*Lt(a,e),e),sqrN:i=>i*i,addN:(i,a)=>i+a,subN:(i,a)=>i-a,mulN:(i,a)=>i*a,inv:i=>Lt(i,e),sqrt:r.sqrt||(i=>f(c,i)),invertBatch:i=>_e(c,i),cmov:(i,a,b)=>b?a:i,toBytes:i=>t?de(i,o):dt(i,o),fromBytes:i=>{if(i.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${i.length}`);return t?Ft(i):Z(i)}});return Object.freeze(c)}function Ne(e,n,t=!1){e=C("privateHash",e);const r=e.length,s=Ut(n).nByteLength+8;if(s<24||r<s||r>1024)throw new Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${r}`);const o=t?Ft(e):Z(e);return T(o,n-H)+H}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Le=BigInt(0),qt=BigInt(1);function He(e,n){const t=(s,o)=>{const f=o.negate();return s?f:o},r=s=>{const o=Math.ceil(n/s)+1,f=2**(s-1);return{windows:o,windowSize:f}};return{constTimeNegate:t,unsafeLadder(s,o){let f=e.ZERO,c=s;for(;o>Le;)o&qt&&(f=f.add(c)),c=c.double(),o>>=qt;return f},precomputeWindow(s,o){const{windows:f,windowSize:c}=r(o),i=[];let a=s,b=a;for(let l=0;l<f;l++){b=a,i.push(b);for(let B=1;B<c;B++)b=b.add(a),i.push(b);a=b.double()}return i},wNAF(s,o,f){const{windows:c,windowSize:i}=r(s);let a=e.ZERO,b=e.BASE;const l=BigInt(2**s-1),B=2**s,E=BigInt(s);for(let w=0;w<c;w++){const u=w*i;let d=Number(f&l);f>>=E,d>i&&(d-=B,f+=qt);const h=u,y=u+Math.abs(d)-1,p=w%2!==0,q=d<0;d===0?b=b.add(t(p,o[h])):a=a.add(t(q,o[y]))}return{p:a,f:b}},wNAFCached(s,o,f,c){const i=s._WINDOW_SIZE||1;let a=o.get(s);return a||(a=this.precomputeWindow(s,i),i!==1&&o.set(s,c(a))),this.wNAF(i,a,f)}}}function re(e){return ne(e.Fp),wt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ut(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Re(e){const n=re(e);wt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=n;if(t){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:Te,hexToBytes:Ue}=be,ct={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(e){const{Err:n}=ct;if(e.length<2||e[0]!==2)throw new n("Invalid signature integer tag");const t=e[1],r=e.subarray(2,t+2);if(!t||r.length!==t)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:Te(r),l:e.subarray(t+2)}},toSig(e){const{Err:n}=ct,t=typeof e=="string"?Ue(e):e;if(!(t instanceof Uint8Array))throw new Error("ui8a expected");let r=t.length;if(r<2||t[0]!=48)throw new n("Invalid signature tag");if(t[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:s,l:o}=ct._parseInt(t.subarray(2)),{d:f,l:c}=ct._parseInt(o);if(c.length)throw new n("Invalid signature: left bytes after parsing");return{r:s,s:f}},hexFromSig(e){const n=a=>Number.parseInt(a[0],16)&8?"00"+a:a,t=a=>{const b=a.toString(16);return b.length&1?`0${b}`:b},r=n(t(e.s)),s=n(t(e.r)),o=r.length/2,f=s.length/2,c=t(o),i=t(f);return`30${t(f+o+4)}02${i}${s}02${c}${r}`}},G=BigInt(0),R=BigInt(1),W=BigInt(2),yt=BigInt(3),Yt=BigInt(4);function Ce(e){const n=Re(e),{Fp:t}=n,r=n.toBytes||((w,u,d)=>{const h=u.toAffine();return j(Uint8Array.from([4]),t.toBytes(h.x),t.toBytes(h.y))}),s=n.fromBytes||(w=>{const u=w.subarray(1),d=t.fromBytes(u.subarray(0,t.BYTES)),h=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:d,y:h}});function o(w){const{a:u,b:d}=n,h=t.sqr(w),y=t.mul(h,w);return t.add(t.add(y,t.mul(w,u)),d)}if(!t.eql(t.sqr(n.Gy),o(n.Gx)))throw new Error("bad generator point: equation left != right");function f(w){return typeof w=="bigint"&&G<w&&w<n.n}function c(w){if(!f(w))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function i(w){const{allowedPrivateKeyLengths:u,nByteLength:d,wrapPrivateKey:h,n:y}=n;if(u&&typeof w!="bigint"){if(w instanceof Uint8Array&&(w=Ot(w)),typeof w!="string"||!u.includes(w.length))throw new Error("Invalid key");w=w.padStart(d*2,"0")}let p;try{p=typeof w=="bigint"?w:Z(C("private key",w,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof w}`)}return h&&(p=T(p,y)),c(p),p}const a=new Map;function b(w){if(!(w instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(u,d,h){if(this.px=u,this.py=d,this.pz=h,u==null||!t.isValid(u))throw new Error("x required");if(d==null||!t.isValid(d))throw new Error("y required");if(h==null||!t.isValid(h))throw new Error("z required")}static fromAffine(u){const{x:d,y:h}=u||{};if(!u||!t.isValid(d)||!t.isValid(h))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");const y=p=>t.eql(p,t.ZERO);return y(d)&&y(h)?l.ZERO:new l(d,h,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const d=t.invertBatch(u.map(h=>h.pz));return u.map((h,y)=>h.toAffine(d[y])).map(l.fromAffine)}static fromHex(u){const d=l.fromAffine(s(C("pointHex",u)));return d.assertValidity(),d}static fromPrivateKey(u){return l.BASE.multiply(i(u))}_setWindowSize(u){this._WINDOW_SIZE=u,a.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:u,y:d}=this.toAffine();if(!t.isValid(u)||!t.isValid(d))throw new Error("bad point: x or y not FE");const h=t.sqr(d),y=o(u);if(!t.eql(h,y))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){b(u);const{px:d,py:h,pz:y}=this,{px:p,py:q,pz:S}=u,x=t.eql(t.mul(d,S),t.mul(p,y)),v=t.eql(t.mul(h,S),t.mul(q,y));return x&&v}negate(){return new l(this.px,t.neg(this.py),this.pz)}double(){const{a:u,b:d}=n,h=t.mul(d,yt),{px:y,py:p,pz:q}=this;let S=t.ZERO,x=t.ZERO,v=t.ZERO,I=t.mul(y,y),z=t.mul(p,p),L=t.mul(q,q),_=t.mul(y,p);return _=t.add(_,_),v=t.mul(y,q),v=t.add(v,v),S=t.mul(u,v),x=t.mul(h,L),x=t.add(S,x),S=t.sub(z,x),x=t.add(z,x),x=t.mul(S,x),S=t.mul(_,S),v=t.mul(h,v),L=t.mul(u,L),_=t.sub(I,L),_=t.mul(u,_),_=t.add(_,v),v=t.add(I,I),I=t.add(v,I),I=t.add(I,L),I=t.mul(I,_),x=t.add(x,I),L=t.mul(p,q),L=t.add(L,L),I=t.mul(L,_),S=t.sub(S,I),v=t.mul(L,z),v=t.add(v,v),v=t.add(v,v),new l(S,x,v)}add(u){b(u);const{px:d,py:h,pz:y}=this,{px:p,py:q,pz:S}=u;let x=t.ZERO,v=t.ZERO,I=t.ZERO;const z=n.a,L=t.mul(n.b,yt);let _=t.mul(d,p),V=t.mul(h,q),P=t.mul(y,S),X=t.add(d,h),g=t.add(p,q);X=t.mul(X,g),g=t.add(_,V),X=t.sub(X,g),g=t.add(d,y);let m=t.add(p,S);return g=t.mul(g,m),m=t.add(_,P),g=t.sub(g,m),m=t.add(h,y),x=t.add(q,S),m=t.mul(m,x),x=t.add(V,P),m=t.sub(m,x),I=t.mul(z,g),x=t.mul(L,P),I=t.add(x,I),x=t.sub(V,I),I=t.add(V,I),v=t.mul(x,I),V=t.add(_,_),V=t.add(V,_),P=t.mul(z,P),g=t.mul(L,g),V=t.add(V,P),P=t.sub(_,P),P=t.mul(z,P),g=t.add(g,P),_=t.mul(V,g),v=t.add(v,_),_=t.mul(m,g),x=t.mul(X,x),x=t.sub(x,_),_=t.mul(X,V),I=t.mul(m,I),I=t.add(I,_),new l(x,v,I)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return E.wNAFCached(this,a,u,d=>{const h=t.invertBatch(d.map(y=>y.pz));return d.map((y,p)=>y.toAffine(h[p])).map(l.fromAffine)})}multiplyUnsafe(u){const d=l.ZERO;if(u===G)return d;if(c(u),u===R)return this;const{endo:h}=n;if(!h)return E.unsafeLadder(this,u);let{k1neg:y,k1:p,k2neg:q,k2:S}=h.splitScalar(u),x=d,v=d,I=this;for(;p>G||S>G;)p&R&&(x=x.add(I)),S&R&&(v=v.add(I)),I=I.double(),p>>=R,S>>=R;return y&&(x=x.negate()),q&&(v=v.negate()),v=new l(t.mul(v.px,h.beta),v.py,v.pz),x.add(v)}multiply(u){c(u);let d=u,h,y;const{endo:p}=n;if(p){const{k1neg:q,k1:S,k2neg:x,k2:v}=p.splitScalar(d);let{p:I,f:z}=this.wNAF(S),{p:L,f:_}=this.wNAF(v);I=E.constTimeNegate(q,I),L=E.constTimeNegate(x,L),L=new l(t.mul(L.px,p.beta),L.py,L.pz),h=I.add(L),y=z.add(_)}else{const{p:q,f:S}=this.wNAF(d);h=q,y=S}return l.normalizeZ([h,y])[0]}multiplyAndAddUnsafe(u,d,h){const y=l.BASE,p=(S,x)=>x===G||x===R||!S.equals(y)?S.multiplyUnsafe(x):S.multiply(x),q=p(this,d).add(p(u,h));return q.is0()?void 0:q}toAffine(u){const{px:d,py:h,pz:y}=this,p=this.is0();u==null&&(u=p?t.ONE:t.inv(y));const q=t.mul(d,u),S=t.mul(h,u),x=t.mul(y,u);if(p)return{x:t.ZERO,y:t.ZERO};if(!t.eql(x,t.ONE))throw new Error("invZ was invalid");return{x:q,y:S}}isTorsionFree(){const{h:u,isTorsionFree:d}=n;if(u===R)return!0;if(d)return d(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:d}=n;return u===R?this:d?d(l,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return this.assertValidity(),r(l,this,u)}toHex(u=!0){return Ot(this.toRawBytes(u))}}l.BASE=new l(n.Gx,n.Gy,t.ONE),l.ZERO=new l(t.ZERO,t.ONE,t.ZERO);const B=n.nBitLength,E=He(l,n.endo?Math.ceil(B/2):B);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:i,weierstrassEquation:o,isWithinCurveOrder:f}}function ke(e){const n=re(e);return wt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Ze(e){const n=ke(e),{Fp:t,n:r}=n,s=t.BYTES+1,o=2*t.BYTES+1;function f(g){return G<g&&g<t.ORDER}function c(g){return T(g,r)}function i(g){return Lt(g,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:b,weierstrassEquation:l,isWithinCurveOrder:B}=Ce({...n,toBytes(g,m,A){const N=m.toAffine(),O=t.toBytes(N.x),k=j;return A?k(Uint8Array.from([m.hasEvenY()?2:3]),O):k(Uint8Array.from([4]),O,t.toBytes(N.y))},fromBytes(g){const m=g.length,A=g[0],N=g.subarray(1);if(m===s&&(A===2||A===3)){const O=Z(N);if(!f(O))throw new Error("Point is not on curve");const k=l(O);let D=t.sqrt(k);const $=(D&R)===R;return(A&1)===1!==$&&(D=t.neg(D)),{x:O,y:D}}else if(m===o&&A===4){const O=t.fromBytes(N.subarray(0,t.BYTES)),k=t.fromBytes(N.subarray(t.BYTES,2*t.BYTES));return{x:O,y:k}}else throw new Error(`Point of length ${m} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),E=g=>Ot(dt(g,n.nByteLength));function w(g){const m=r>>R;return g>m}function u(g){return w(g)?c(-g):g}const d=(g,m,A)=>Z(g.slice(m,A));class h{constructor(m,A,N){this.r=m,this.s=A,this.recovery=N,this.assertValidity()}static fromCompact(m){const A=n.nByteLength;return m=C("compactSignature",m,A*2),new h(d(m,0,A),d(m,A,2*A))}static fromDER(m){const{r:A,s:N}=ct.toSig(C("DER",m));return new h(A,N)}assertValidity(){if(!B(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!B(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new h(this.r,this.s,m)}recoverPublicKey(m){const{r:A,s:N,recovery:O}=this,k=v(C("msgHash",m));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const D=O===2||O===3?A+n.n:A;if(D>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const $=O&1?"03":"02",Q=a.fromHex($+E(D)),J=i(D),ft=c(-k*J),ht=c(N*J),F=a.BASE.multiplyAndAddUnsafe(Q,ft,ht);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return zt(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return zt(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const y={isValidPrivateKey(g){try{return b(g),!0}catch{return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const g=n.randomBytes(t.BYTES+8),m=Ne(g,r);return dt(m,n.nByteLength)},precompute(g=8,m=a.BASE){return m._setWindowSize(g),m.multiply(BigInt(3)),m}};function p(g,m=!0){return a.fromPrivateKey(g).toRawBytes(m)}function q(g){const m=g instanceof Uint8Array,A=typeof g=="string",N=(m||A)&&g.length;return m?N===s||N===o:A?N===2*s||N===2*o:g instanceof a}function S(g,m,A=!0){if(q(g))throw new Error("first arg must be private key");if(!q(m))throw new Error("second arg must be public key");return a.fromHex(m).multiply(b(g)).toRawBytes(A)}const x=n.bits2int||function(g){const m=Z(g),A=g.length*8-n.nBitLength;return A>0?m>>BigInt(A):m},v=n.bits2int_modN||function(g){return c(x(g))},I=Jt(n.nBitLength);function z(g){if(typeof g!="bigint")throw new Error("bigint expected");if(!(G<=g&&g<I))throw new Error(`bigint expected < 2^${n.nBitLength}`);return dt(g,n.nByteLength)}function L(g,m,A=_){if(["recovered","canonical"].some(st=>st in A))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:O}=n;let{lowS:k,prehash:D,extraEntropy:$}=A;k==null&&(k=!0),g=C("msgHash",g),D&&(g=C("prehashed msgHash",N(g)));const Q=v(g),J=b(m),ft=[z(J),z(Q)];if($!=null){const st=$===!0?O(t.BYTES):$;ft.push(C("extraEntropy",st,t.BYTES))}const ht=j(...ft),F=Q;function At(st){const at=x(st);if(!B(at))return;const Vt=i(at),ut=a.BASE.multiply(at).toAffine(),Y=c(ut.x);if(Y===G)return;const lt=c(Vt*c(F+Y*J));if(lt===G)return;let Pt=(ut.x===Y?0:2)|Number(ut.y&R),$t=lt;return k&&w(lt)&&($t=u(lt),Pt^=1),new h(Y,$t,Pt)}return{seed:ht,k2sig:At}}const _={lowS:n.lowS,prehash:!1},V={lowS:n.lowS,prehash:!1};function P(g,m,A=_){const{seed:N,k2sig:O}=L(g,m,A);return he(n.hash.outputLen,n.nByteLength,n.hmac)(N,O)}a.BASE._setWindowSize(8);function X(g,m,A,N=V){var ut;const O=g;if(m=C("msgHash",m),A=C("publicKey",A),"strict"in N)throw new Error("options.strict was renamed to lowS");const{lowS:k,prehash:D}=N;let $,Q;try{if(typeof O=="string"||O instanceof Uint8Array)try{$=h.fromDER(O)}catch(Y){if(!(Y instanceof ct.Err))throw Y;$=h.fromCompact(O)}else if(typeof O=="object"&&typeof O.r=="bigint"&&typeof O.s=="bigint"){const{r:Y,s:lt}=O;$=new h(Y,lt)}else throw new Error("PARSE");Q=a.fromHex(A)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(k&&$.hasHighS())return!1;D&&(m=n.hash(m));const{r:J,s:ft}=$,ht=v(m),F=i(ft),At=c(ht*F),st=c(J*F),at=(ut=a.BASE.multiplyAndAddUnsafe(Q,At,st))==null?void 0:ut.toAffine();return at?c(at.x)===J:!1}return{CURVE:n,getPublicKey:p,getSharedSecret:S,sign:P,verify:X,ProjectivePoint:a,Signature:h,utils:y}}function Ve(e,n){const t=e.ORDER;let r=G;for(let B=t-R;B%W===G;B/=W)r+=R;const s=r,o=(t-R)/W**s,f=(o-R)/W,c=W**s-R,i=W**(s-R),a=e.pow(n,o),b=e.pow(n,(o+R)/W);let l=(B,E)=>{let w=a,u=e.pow(E,c),d=e.sqr(u);d=e.mul(d,E);let h=e.mul(B,d);h=e.pow(h,f),h=e.mul(h,u),u=e.mul(h,E),d=e.mul(h,B);let y=e.mul(d,u);h=e.pow(y,i);let p=e.eql(h,e.ONE);u=e.mul(d,b),h=e.mul(y,w),d=e.cmov(u,d,p),y=e.cmov(h,y,p);for(let q=s;q>R;q--){let S=W**(q-W),x=e.pow(y,S);const v=e.eql(x,e.ONE);u=e.mul(d,w),w=e.mul(w,w),x=e.mul(y,w),d=e.cmov(u,d,v),y=e.cmov(x,y,v)}return{isValid:p,value:d}};if(e.ORDER%Yt===yt){const B=(e.ORDER-yt)/Yt,E=e.sqrt(e.neg(n));l=(w,u)=>{let d=e.sqr(u);const h=e.mul(w,u);d=e.mul(d,h);let y=e.pow(d,B);y=e.mul(y,h);const p=e.mul(y,E),q=e.mul(e.sqr(y),u),S=e.eql(q,w);let x=e.cmov(p,y,S);return{isValid:S,value:x}}}return l}function Pe(e,n){if(ne(e),!e.isValid(n.A)||!e.isValid(n.B)||!e.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const t=Ve(e,n.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,o,f,c,i,a,b,l;s=e.sqr(r),s=e.mul(s,n.Z),o=e.sqr(s),o=e.add(o,s),f=e.add(o,e.ONE),f=e.mul(f,n.B),c=e.cmov(n.Z,e.neg(o),!e.eql(o,e.ZERO)),c=e.mul(c,n.A),o=e.sqr(f),a=e.sqr(c),i=e.mul(a,n.A),o=e.add(o,i),o=e.mul(o,f),a=e.mul(a,c),i=e.mul(a,n.B),o=e.add(o,i),b=e.mul(s,f);const{isValid:B,value:E}=t(o,a);l=e.mul(s,r),l=e.mul(l,E),b=e.cmov(b,f,B),l=e.cmov(l,E,B);const w=e.isOdd(r)===e.isOdd(l);return l=e.cmov(e.neg(l),l,w),b=e.div(b,c),{x:b,y:l}}}function $e(e){if(e instanceof Uint8Array)return e;if(typeof e=="string")return Tt(e);throw new Error("DST must be Uint8Array or string")}const ze=Z;function nt(e,n){if(e<0||e>=1<<8*n)throw new Error(`bad I2OSP call: value=${e} length=${n}`);const t=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)t[r]=e&255,e>>>=8;return new Uint8Array(t)}function De(e,n){const t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e[r]^n[r];return t}function bt(e){if(!(e instanceof Uint8Array))throw new Error("Uint8Array expected")}function Ct(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function Ke(e,n,t,r){bt(e),bt(n),Ct(t),n.length>255&&(n=r(j(Tt("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:o}=r,f=Math.ceil(t/s);if(f>255)throw new Error("Invalid xmd length");const c=j(n,nt(n.length,1)),i=nt(0,o),a=nt(t,2),b=new Array(f),l=r(j(i,e,a,nt(0,1),c));b[0]=r(j(l,nt(1,1),c));for(let E=1;E<=f;E++){const w=[De(l,b[E-1]),nt(E+1,1),c];b[E]=r(j(...w))}return j(...b).slice(0,t)}function Ye(e,n,t,r,s){if(bt(e),bt(n),Ct(t),n.length>255){const o=Math.ceil(2*r/8);n=s.create({dkLen:o}).update(Tt("H2C-OVERSIZE-DST-")).update(n).digest()}if(t>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:t}).update(e).update(nt(t,2)).update(n).update(nt(n.length,1)).digest()}function jt(e,n,t){wt(t,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:o,hash:f,expand:c,DST:i}=t;bt(e),Ct(n);const a=$e(i),b=r.toString(2).length,l=Math.ceil((b+s)/8),B=n*o*l;let E;if(c==="xmd")E=Ke(e,a,B,f);else if(c==="xof")E=Ye(e,a,B,s,f);else if(c==="_internal_pass")E=e;else throw new Error('expand must be "xmd" or "xof"');const w=new Array(n);for(let u=0;u<n;u++){const d=new Array(o);for(let h=0;h<o;h++){const y=l*(h+u*o),p=E.subarray(y,y+l);d[h]=T(ze(p),r)}w[u]=d}return w}function je(e,n){const t=n.map(r=>Array.from(r).reverse());return(r,s)=>{const[o,f,c,i]=t.map(a=>a.reduce((b,l)=>e.add(e.mul(b,r),l)));return r=e.div(o,f),s=e.mul(s,e.div(c,i)),{x:r,y:s}}}function Ge(e,n,t){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,s){const o=jt(r,2,{...t,DST:t.DST,...s}),f=e.fromAffine(n(o[0])),c=e.fromAffine(n(o[1])),i=f.add(c).clearCofactor();return i.assertValidity(),i},encodeToCurve(r,s){const o=jt(r,1,{...t,DST:t.encodeDST,...s}),f=e.fromAffine(n(o[0])).clearCofactor();return f.assertValidity(),f}}}class se extends Wt{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,it.hash(n);const r=Xt(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?n.create().update(r).digest():r);for(let f=0;f<o.length;f++)o[f]^=54;this.iHash.update(o),this.oHash=n.create();for(let f=0;f<o.length;f++)o[f]^=106;this.oHash.update(o),o.fill(0)}update(n){return it.exists(this),this.iHash.update(n),this}digestInto(n){it.exists(this),it.bytes(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:o,blockLen:f,outputLen:c}=this;return n=n,n.finished=s,n.destroyed=o,n.blockLen=f,n.outputLen=c,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const oe=(e,n,t)=>new se(e,n).update(t).digest();oe.create=(e,n)=>new se(e,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Me(e){return{hash:e,hmac:(n,...t)=>oe(e,n,ge(...t)),randomBytes:te}}function We(e,n){const t=r=>Ze({...e,...Me(r)});return Object.freeze({...t(n),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Bt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),xt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ie=BigInt(1),Et=BigInt(2),Gt=(e,n)=>(e+n/Et)/n;function ce(e){const n=Bt,t=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),f=BigInt(23),c=BigInt(44),i=BigInt(88),a=e*e*e%n,b=a*a*e%n,l=K(b,t,n)*b%n,B=K(l,t,n)*b%n,E=K(B,Et,n)*a%n,w=K(E,s,n)*E%n,u=K(w,o,n)*w%n,d=K(u,c,n)*u%n,h=K(d,i,n)*d%n,y=K(h,c,n)*u%n,p=K(y,t,n)*b%n,q=K(p,f,n)*w%n,S=K(q,r,n)*a%n,x=K(S,Et,n);if(!rt.eql(rt.sqr(x),e))throw new Error("Cannot find square root");return x}const rt=Oe(Bt,void 0,void 0,{sqrt:ce}),vt=We({a:BigInt(0),b:BigInt(7),Fp:rt,n:xt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=xt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-ie*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,f=BigInt("0x100000000000000000000000000000000"),c=Gt(o*e,n),i=Gt(-r*e,n);let a=T(e-c*t-i*s,n),b=T(-c*r-i*o,n);const l=a>f,B=b>f;if(l&&(a=n-a),B&&(b=n-b),a>f||b>f)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:l,k1:a,k2neg:B,k2:b}}}},mt),St=BigInt(0),fe=e=>typeof e=="bigint"&&St<e&&e<Bt,Xe=e=>typeof e=="bigint"&&St<e&&e<xt,Mt={};function pt(e,...n){let t=Mt[e];if(t===void 0){const r=mt(Uint8Array.from(e,s=>s.charCodeAt(0)));t=j(r,r),Mt[e]=t}return mt(j(t,...n))}const kt=e=>e.toRawBytes(!0).slice(1),Ht=e=>dt(e,32),_t=e=>T(e,Bt),gt=e=>T(e,xt),Zt=vt.ProjectivePoint,Qe=(e,n,t)=>Zt.BASE.multiplyAndAddUnsafe(e,n,t);function Rt(e){let n=vt.utils.normPrivateKeyToScalar(e),t=Zt.fromPrivateKey(n);return{scalar:t.hasEvenY()?n:gt(-n),bytes:kt(t)}}function ae(e){if(!fe(e))throw new Error("bad x: need 0 < x < p");const n=_t(e*e),t=_t(n*e+BigInt(7));let r=ce(t);r%Et!==St&&(r=_t(-r));const s=new Zt(e,r,ie);return s.assertValidity(),s}function ue(...e){return gt(Z(pt("BIP0340/challenge",...e)))}function Je(e){return Rt(e).bytes}function Fe(e,n,t=te(32)){const r=C("message",e),{bytes:s,scalar:o}=Rt(n),f=C("auxRand",t,32),c=Ht(o^Z(pt("BIP0340/aux",f))),i=pt("BIP0340/nonce",c,s,r),a=gt(Z(i));if(a===St)throw new Error("sign failed: k is zero");const{bytes:b,scalar:l}=Rt(a),B=ue(b,s,r),E=new Uint8Array(64);if(E.set(b,0),E.set(Ht(gt(l+B*o)),32),!le(E,r,s))throw new Error("sign: Invalid signature produced");return E}function le(e,n,t){const r=C("signature",e,64),s=C("message",n),o=C("publicKey",t,32);try{const f=ae(Z(o)),c=Z(r.subarray(0,32));if(!fe(c))return!1;const i=Z(r.subarray(32,64));if(!Xe(i))return!1;const a=ue(Ht(c),kt(f),s),b=Qe(f,i,gt(-a));return!(!b||!b.hasEvenY()||b.toAffine().x!==c)}catch{return!1}}const sn={getPublicKey:Je,sign:Fe,verify:le,utils:{randomPrivateKey:vt.utils.randomPrivateKey,lift_x:ae,pointToBytes:kt,numberToBytesBE:dt,bytesToNumberBE:Z,taggedHash:pt,mod:T}},tn=je(rt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(e=>e.map(n=>BigInt(n)))),en=Pe(rt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:rt.create(BigInt("-11"))}),{hashToCurve:on,encodeToCurve:cn}=Ge(vt.ProjectivePoint,e=>{const{x:n,y:t}=en(rt.create(e[0]));return tn(n,t)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:rt.ORDER,m:1,k:128,expand:"xmd",hash:mt});export{cn as encodeToCurve,on as hashToCurve,sn as schnorr,vt as secp256k1};
